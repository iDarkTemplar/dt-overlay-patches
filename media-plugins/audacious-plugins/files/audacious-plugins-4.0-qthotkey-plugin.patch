From 594227ee3c11bc1821161248f88d31af71d09dbe Mon Sep 17 00:00:00 2001
From: "i.Dark_Templar" <darktemplar@dark-templar-archives.net>
Date: Sun, 12 Apr 2020 16:24:36 +0300
Subject: [PATCH] Implement qthotkey plugin

Global hotkeys plugin for qt5 interface
based on hotkey plugin for gtk interface.
---
 acinclude.m4           |   2 +-
 configure.ac           |  10 +-
 src/qthotkey/Makefile  |  19 ++
 src/qthotkey/gui.cc    | 329 +++++++++++++++++++
 src/qthotkey/gui.h     |  60 ++++
 src/qthotkey/plugin.cc | 696 +++++++++++++++++++++++++++++++++++++++++
 src/qthotkey/plugin.h  |  50 +++
 7 files changed, 1164 insertions(+), 2 deletions(-)
 create mode 100644 src/qthotkey/Makefile
 create mode 100644 src/qthotkey/gui.cc
 create mode 100644 src/qthotkey/gui.h
 create mode 100644 src/qthotkey/plugin.cc
 create mode 100644 src/qthotkey/plugin.h

diff --git a/acinclude.m4 b/acinclude.m4
index 5e25b37b9..b7c71487f 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -218,7 +218,7 @@ AC_ARG_ENABLE(qt,
 if test $USE_QT = yes ; then
     PKG_CHECK_MODULES([QTCORE], [Qt5Core >= 5.2])
     PKG_CHECK_VAR([QTBINPATH], [Qt5Core >= 5.2], [host_bins])
-    PKG_CHECK_MODULES([QT], [Qt5Core Qt5Gui Qt5Widgets >= 5.2])
+    PKG_CHECK_MODULES([QT], [Qt5Core Qt5Gui Qt5Widgets Qt5X11Extras >= 5.2])
     AC_DEFINE([USE_QT], [1], [Define if Qt support enabled])
 
     # needed if Qt was built with -reduce-relocations
diff --git a/configure.ac b/configure.ac
index c7f8c85c9..5337df031 100644
--- a/configure.ac
+++ b/configure.ac
@@ -103,7 +103,7 @@ check_allowed () {
                 AC_MSG_ERROR([--enable-$1 cannot be used without --enable-gtk])
             fi
             ;;
-        ampache|qtaudio|qtglspectrum)
+        ampache|qtaudio|qtglspectrum|qthotkey)
             plugin_allowed=$USE_QT
             if test $plugin_allowed = no -a $2 = yes ; then
                 AC_MSG_ERROR([--enable-$1 cannot be used without --enable-qt])
@@ -533,6 +533,13 @@ ENABLE_PLUGIN_WITH_TEST(qtglspectrum,
     auto,
     VISUALIZATION)
 
+ENABLE_PLUGIN_WITH_DEP(qthotkey,
+    global hotkeys (X11),
+    auto,
+    GENERAL,
+    QTX11EXTRAS,
+    Qt5X11Extras)
+
 dnl CoreAudio
 dnl =========
 
@@ -844,6 +851,7 @@ if test "x$USE_QT" = "xyes" ; then
     echo "  Status Icon:                            yes"
     echo "  Stream Tuner:                           $have_streamtuner"
     echo "  VU Meter:                               yes"
+    echo "  X11 Global Hotkeys:                     $have_qthotkey"
     echo
 fi
 
diff --git a/src/qthotkey/Makefile b/src/qthotkey/Makefile
new file mode 100644
index 000000000..70fb02a35
--- /dev/null
+++ b/src/qthotkey/Makefile
@@ -0,0 +1,19 @@
+PLUGIN = qthotkey${PLUGIN_SUFFIX}
+
+SRCS = plugin.cc gui.cc moc_plugin.cc moc_gui.cc
+
+include ../../buildsys.mk
+include ../../extra.mk
+
+plugindir := ${plugindir}/${GENERAL_PLUGIN_DIR}
+
+LD = ${CXX}
+CFLAGS += ${PLUGIN_CFLAGS}
+CPPFLAGS += ${PLUGIN_CPPFLAGS} ${QT_CFLAGS} -I../.. -I..
+LIBS += ${QT_LIBS} -lX11
+
+moc_%.cc: %.h
+	moc $< -o $@
+
+rc_%.cc: %.qrc
+	rcc $< -o $@
diff --git a/src/qthotkey/gui.cc b/src/qthotkey/gui.cc
new file mode 100644
index 000000000..4d6a0ee5e
--- /dev/null
+++ b/src/qthotkey/gui.cc
@@ -0,0 +1,329 @@
+/*
+ *  This file is part of audacious-hotkey plugin for audacious
+ *
+ *  Copyright (C) 2020 i.Dark_Templar <darktemplar@dark-templar-archives.net>
+ *  Copyright (c) 2007 - 2008  Sascha Hlusiak <contact@saschahlusiak.de>
+ *  Name: gui.c
+ *  Description: gui.c
+ *
+ *  Part of this code is from itouch-ctrl plugin.
+ *  Authors of itouch-ctrl are listed below:
+ *
+ *  Copyright (c) 2006 - 2007 Vladimir Paskov <vlado.paskov@gmail.com>
+ *
+ *  Part of this code are from xmms-itouch plugin.
+ *  Authors of xmms-itouch are listed below:
+ *
+ *  Copyright (C) 2000-2002 Ville Syrjälä <syrjala@sci.fi>
+ *                         Bryn Davies <curious@ihug.com.au>
+ *                         Jonathan A. Davis <davis@jdhouse.org>
+ *                         Jeremy Tan <nsx@nsx.homeip.net>
+ *
+ *  audacious-hotkey is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  audacious-hotkey is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with audacious-hotkey; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include "plugin.h"
+#include "gui.h"
+
+#include <libaudcore/i18n.h>
+#include <libaudcore/preferences.h>
+
+#include <QtCore/QStringList>
+#include <QtGui/QKeyEvent>
+#include <QtGui/QMouseEvent>
+#include <QtWidgets/QApplication>
+#include <QtWidgets/QStyle>
+#include <QtX11Extras/QX11Info>
+
+#include <X11/XKBlib.h>
+
+static void destroy_callback();
+static void ok_callback();
+
+static QPrefWidget *last_instance = nullptr;
+
+static const char *event_desc[EVENT_MAX] = {
+	[EVENT_PREV_TRACK] = N_("Previous track"),
+	[EVENT_PLAY] = N_("Play"),
+	[EVENT_PAUSE] = N_("Pause/Resume"),
+	[EVENT_STOP] = N_("Stop"),
+	[EVENT_NEXT_TRACK] = N_("Next track"),
+	[EVENT_FORWARD] = N_("Step forward"),
+	[EVENT_BACKWARD] = N_("Step backward"),
+	[EVENT_MUTE] = N_("Mute"),
+	[EVENT_VOL_UP] = N_("Volume up"),
+	[EVENT_VOL_DOWN] = N_("Volume down"),
+	[EVENT_JUMP_TO_FILE] = N_("Jump to file"),
+	[EVENT_TOGGLE_WIN] = N_("Toggle player window(s)"),
+	[EVENT_SHOW_AOSD] = N_("Show On-Screen-Display"),
+	[EVENT_TOGGLE_REPEAT] = N_("Toggle repeat"),
+	[EVENT_TOGGLE_SHUFFLE] = N_("Toggle shuffle"),
+	[EVENT_TOGGLE_STOP] = N_("Toggle stop after current"),
+	[EVENT_RAISE] = N_("Raise player window(s)")
+};
+
+class QLineKeyEdit: public QLineEdit
+{
+public:
+	explicit QLineKeyEdit(QWidget *parent, HotkeyConfiguration &hotkey)
+		: QLineEdit(parent),
+		m_hotkey(hotkey)
+	{
+		set_keytext(0, 0);
+	}
+
+	void set_keytext(int key, int mask)
+	{
+		QString text;
+
+		if ((key == 0) && (mask == 0))
+		{
+			text = QString::fromLocal8Bit(_("(none)"));
+		}
+		else
+		{
+			static const char *modifier_string[] = { "Control", "Shift", "Alt", "Mod2", "Mod3", "Super", "Mod5" };
+			static const unsigned int modifiers[] = { ControlMask, ShiftMask, Mod1Mask, Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask };
+
+			QStringList strings;
+
+			KeySym keysym;
+			keysym = XkbKeycodeToKeysym(QX11Info::display(), key, 0, 0);
+			if (keysym == 0 || keysym == NoSymbol)
+			{
+				text = QString::fromLocal8Bit("#%1").arg(key);
+			}
+			else
+			{
+				text = QString::fromLocal8Bit(XKeysymToString(keysym));
+			}
+
+			for (int j = 0; j < sizeof(modifiers)/sizeof(modifiers[0]); ++j)
+			{
+				if (mask & modifiers[j])
+				{
+					strings.push_back(QString::fromLatin1(modifier_string[j]));
+				}
+			}
+
+			if (key != 0)
+			{
+				strings.push_back(text);
+			}
+
+			text = strings.join(QLatin1String(" + "));
+		}
+
+		setText(text);
+
+		m_hotkey.key = key;
+		m_hotkey.mask = mask;
+	}
+
+protected:
+	void keyPressEvent(QKeyEvent *event) override
+	{
+		set_keytext(event->nativeScanCode(), event->nativeModifiers());
+	}
+
+private:
+	HotkeyConfiguration &m_hotkey;
+};
+
+KeyControls::~KeyControls()
+{
+	delete combobox;
+	delete keytext;
+	delete button;
+}
+
+QPrefWidget::QPrefWidget(QWidget *parent)
+	: QWidget(parent),
+	main_widget_layout(new QVBoxLayout(this)),
+	information_pixmap(new QLabel(this)),
+	information_label(new QLabel(QString::fromLocal8Bit(_("Press a key combination inside a text field.")), this)),
+	information_layout(new QHBoxLayout()),
+	group_box(new QGroupBox(QString::fromLocal8Bit(_("Hotkeys:")), this)),
+	group_box_layout(new QGridLayout(group_box)),
+	action_label(new QLabel(QString::fromLocal8Bit(_("<b>Action:</b>")), group_box)),
+	key_binding_label(new QLabel(QString::fromLocal8Bit(_("<b>Key Binding:</b>")), group_box)),
+	add_button(new QPushButton(QIcon::fromTheme(QLatin1String("list-add")), QString::fromLocal8Bit(_("_Add")), this)),
+	add_button_layout(new QHBoxLayout)
+{
+	int icon_size = QApplication::style()->pixelMetric(QStyle::PM_MessageBoxIconSize);
+	information_pixmap->setPixmap(QApplication::style()->standardIcon(QStyle::SP_MessageBoxInformation).pixmap(QSize(icon_size, icon_size)));
+
+	information_layout->addWidget(information_pixmap, 0, Qt::AlignLeft);
+	information_layout->addWidget(information_label, 0, Qt::AlignLeft);
+	information_layout->addStretch();
+
+	action_label->setAlignment(Qt::AlignHCenter);
+	key_binding_label->setAlignment(Qt::AlignHCenter);
+
+	group_box->setLayout(group_box_layout);
+	group_box_layout->addWidget(action_label, 0, 0);
+	group_box_layout->addWidget(key_binding_label, 0, 1);
+
+	for (const auto &hotkey: get_config()->hotkeys_list)
+	{
+		add_event_control(&hotkey);
+	}
+
+	add_button_layout->addWidget(add_button);
+	add_button_layout->addStretch();
+
+	this->setLayout(main_widget_layout);
+
+	main_widget_layout->addLayout(information_layout);
+	main_widget_layout->addWidget(group_box);
+	main_widget_layout->addLayout(add_button_layout);
+
+	QObject::connect(add_button, &QPushButton::clicked, [this]()
+	{
+		add_event_control(nullptr);
+	});
+
+	last_instance = this;
+}
+
+QPrefWidget::~QPrefWidget()
+{
+	delete information_layout;
+
+	for (auto control: controls_list)
+	{
+		delete control;
+	}
+
+	controls_list.clear();
+
+	if (last_instance == this)
+	{
+		last_instance = nullptr;
+	}
+}
+
+void QPrefWidget::add_event_control(const HotkeyConfiguration *hotkey)
+{
+	KeyControls *control = new KeyControls;
+
+	if (hotkey != nullptr)
+	{
+		control->hotkey.key = hotkey->key;
+		control->hotkey.mask = hotkey->mask;
+		control->hotkey.event = hotkey->event;
+
+		if (control->hotkey.key == 0)
+		{
+			control->hotkey.mask = 0;
+		}
+	}
+	else
+	{
+		control->hotkey.key = 0;
+		control->hotkey.mask = 0;
+		control->hotkey.event = static_cast<EVENT>(0);
+	}
+
+	control->combobox = new QComboBox(group_box);
+
+	for (int i = 0; i < EVENT_MAX; ++i)
+	{
+		control->combobox->addItem(QString::fromLocal8Bit(_(event_desc[i])));
+	}
+
+	if (hotkey != nullptr)
+	{
+		control->combobox->setCurrentIndex(hotkey->event);
+	}
+
+	control->keytext = new QLineKeyEdit(group_box, control->hotkey);
+	control->keytext->setFocus(Qt::OtherFocusReason);
+
+	if (hotkey != nullptr)
+	{
+		control->keytext->set_keytext(hotkey->key, hotkey->mask);
+	}
+
+	control->button = new QToolButton(group_box);
+	control->button->setIcon(QIcon::fromTheme(QLatin1String("edit-delete")));
+
+	int row = group_box_layout->rowCount();
+
+	controls_list.push_back(control);
+
+	group_box_layout->addWidget(control->combobox, row, 0);
+	group_box_layout->addWidget(control->keytext, row, 1);
+	group_box_layout->addWidget(control->button, row, 2);
+
+	QObject::connect(control->button, &QToolButton::clicked, [this, control] ()
+	{
+		controls_list.removeAll(control);
+		delete control;
+	});
+}
+
+QList<HotkeyConfiguration> QPrefWidget::getConfig() const
+{
+	QList<HotkeyConfiguration> result;
+
+	for (const auto &control: controls_list)
+	{
+		HotkeyConfiguration hotkey;
+
+		hotkey.key = control->hotkey.key;
+		hotkey.mask = control->hotkey.mask;
+		hotkey.event = static_cast<EVENT>(control->combobox->currentIndex());
+
+		result.push_back(hotkey);
+	}
+
+	return result;
+}
+
+void *make_config_widget()
+{
+	ungrab_keys();
+
+	QWidget *main_widget = new QPrefWidget;
+
+	return main_widget;
+}
+
+void destroy_callback()
+{
+	grab_keys();
+}
+
+void ok_callback()
+{
+	if (last_instance != nullptr)
+	{
+		PluginConfig *plugin_cfg = get_config();
+		plugin_cfg->hotkeys_list = last_instance->getConfig();
+		save_config();
+	}
+}
+
+static const PreferencesWidget hotkey_widgets[] = {
+	WidgetCustomQt(make_config_widget)
+};
+
+const PluginPreferences hotkey_prefs = {
+	{hotkey_widgets},
+	nullptr,  // init
+	ok_callback,
+	destroy_callback
+};
diff --git a/src/qthotkey/gui.h b/src/qthotkey/gui.h
new file mode 100644
index 000000000..e215c308b
--- /dev/null
+++ b/src/qthotkey/gui.h
@@ -0,0 +1,60 @@
+#ifndef _GUI_H_INCLUDED_
+#define _GUI_H_INCLUDED_
+
+#include <QtCore/QList>
+#include <QtWidgets/QComboBox>
+#include <QtWidgets/QLineEdit>
+#include <QtWidgets/QLabel>
+#include <QtWidgets/QWidget>
+#include <QtWidgets/QGroupBox>
+#include <QtWidgets/QHBoxLayout>
+#include <QtWidgets/QVBoxLayout>
+#include <QtWidgets/QGridLayout>
+#include <QtWidgets/QToolButton>
+#include <QtWidgets/QPushButton>
+
+#include "plugin.h"
+
+class QLineKeyEdit;
+struct PluginPreferences;
+
+extern const PluginPreferences hotkey_prefs;
+
+struct KeyControls {
+	QComboBox *combobox;
+	QLineKeyEdit *keytext;
+	QToolButton *button;
+
+	HotkeyConfiguration hotkey;
+
+	~KeyControls();
+};
+
+class QPrefWidget: public QWidget
+{
+	Q_OBJECT;
+
+public:
+	explicit QPrefWidget(QWidget *parent = nullptr);
+	~QPrefWidget();
+
+	QList<HotkeyConfiguration> getConfig() const;
+
+private:
+	QVBoxLayout *main_widget_layout;
+	QLabel *information_pixmap;
+	QLabel *information_label;
+	QHBoxLayout *information_layout;
+	QGroupBox *group_box;
+	QGridLayout *group_box_layout;
+	QLabel *action_label;
+	QLabel *key_binding_label;
+	QPushButton *add_button;
+	QHBoxLayout *add_button_layout;
+
+	QList<KeyControls* > controls_list;
+
+	void add_event_control(const HotkeyConfiguration *hotkey);
+};
+
+#endif
diff --git a/src/qthotkey/plugin.cc b/src/qthotkey/plugin.cc
new file mode 100644
index 000000000..bd46dde56
--- /dev/null
+++ b/src/qthotkey/plugin.cc
@@ -0,0 +1,696 @@
+/*
+ *  This file is part of audacious-hotkey plugin for audacious
+ *
+ *  Copyright (C) 2020 i.Dark_Templar <darktemplar@dark-templar-archives.net>
+ *  Copyright (c) 2007 - 2008  Sascha Hlusiak <contact@saschahlusiak.de>
+ *  Name: plugin.c
+ *  Description: plugin.c
+ *
+ *  Part of this code is from itouch-ctrl plugin.
+ *  Authors of itouch-ctrl are listed below:
+ *
+ *  Copyright (c) 2006 - 2007 Vladimir Paskov <vlado.paskov@gmail.com>
+ *
+ *  Part of this code are from xmms-itouch plugin.
+ *  Authors of xmms-itouch are listed below:
+ *
+ *  Copyright (C) 2000-2002 Ville Syrjälä <syrjala@sci.fi>
+ *                         Bryn Davies <curious@ihug.com.au>
+ *                         Jonathan A. Davis <davis@jdhouse.org>
+ *                         Jeremy Tan <nsx@nsx.homeip.net>
+ *
+ *  audacious-hotkey is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  audacious-hotkey is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with audacious-hotkey; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#include "plugin.h"
+#include "gui.h"
+
+#include <stdlib.h>
+
+#include <QtCore/QCoreApplication>
+#include <QtCore/QString>
+#include <QtCore/QTimer>
+#include <QtCore/QAbstractNativeEventFilter>
+#include <QtX11Extras/QX11Info>
+
+#include <X11/XF86keysym.h>
+#include <X11/Xlib.h>
+#include <X11/keysym.h>
+#include <xcb/xproto.h>
+
+#include <libaudcore/drct.h>
+#include <libaudcore/hook.h>
+#include <libaudcore/i18n.h>
+#include <libaudcore/interface.h>
+#include <libaudcore/plugin.h>
+#include <libaudcore/runtime.h>
+
+class GlobalHotkeys: public GeneralPlugin, public QAbstractNativeEventFilter
+{
+public:
+	static const char about[];
+
+	static constexpr PluginInfo info = {
+		N_("Global Hotkeys"),
+		PACKAGE,
+		about,
+		&hotkey_prefs,
+		PluginQtOnly
+	};
+
+	GlobalHotkeys()
+		: GeneralPlugin(info, false)
+	{
+	}
+
+	bool init() override;
+	void cleanup() override;
+
+private:
+	bool real_init();
+
+	bool nativeEventFilter(const QByteArray &eventType, void *message, long *result) override;
+};
+
+EXPORT GlobalHotkeys aud_plugin_instance;
+
+/* global vars */
+static PluginConfig plugin_cfg;
+
+static int grabbed = 0;
+static unsigned int numlock_mask = 0;
+static unsigned int scrolllock_mask = 0;
+static unsigned int capslock_mask = 0;
+
+const char GlobalHotkeys::about[] =
+	N_("Global Hotkey Plugin\n"
+	   "Control the player with global key combinations or multimedia keys.\n\n"
+	   "Copyright (C) 2020 i.Dark_Templar <darktemplar@dark-templar-archives.net>\n"
+	   "Copyright (C) 2007-2008 Sascha Hlusiak <contact@saschahlusiak.de>\n\n"
+	   "Contributors include:\n"
+	   "Copyright (C) 2006-2007 Vladimir Paskov <vlado.paskov@gmail.com>\n"
+	   "Copyright (C) 2000-2002 Ville Syrjälä <syrjala@sci.fi>,\n"
+	   " Bryn Davies <curious@ihug.com.au>,\n"
+	   " Jonathan A. Davis <davis@jdhouse.org>,\n"
+	   " Jeremy Tan <nsx@nsx.homeip.net>");
+
+PluginConfig* get_config()
+{
+	return &plugin_cfg;
+}
+
+/*
+ * plugin activated
+ */
+bool GlobalHotkeys::init()
+{
+	/* delay real initialization until qapplication is created */
+	QTimer::singleShot(0, [this] () { this->real_init(); });
+
+	return true;
+}
+
+bool GlobalHotkeys::real_init()
+{
+	if (!QX11Info::isPlatformX11())
+	{
+		AUDERR ("Global Hotkey plugin only supports X11.\n");
+		return false;
+	}
+
+	load_config();
+	grab_keys();
+	QCoreApplication::instance()->installNativeEventFilter(this);
+
+	return true;
+}
+
+/* handle keys */
+bool handle_keyevent (EVENT event)
+{
+	int current_volume, old_volume;
+	static int volume_static = 0;
+	bool mute;
+
+	/* get current volume */
+	current_volume = aud_drct_get_volume_main();
+	old_volume = current_volume;
+
+	if (current_volume)
+	{
+		/* volume is not mute */
+		mute = false;
+	}
+	else
+	{
+		/* volume is mute */
+		mute = true;
+	}
+
+	switch (event)
+	{
+	/* mute the playback */
+	case EVENT_MUTE:
+		{
+			if (!mute)
+			{
+				volume_static = current_volume;
+				aud_drct_set_volume_main(0);
+				mute = true;
+			}
+			else
+			{
+				aud_drct_set_volume_main(volume_static);
+				mute = false;
+			}
+
+			return true;
+		}
+		break;
+
+	/* decrease volume */
+	case EVENT_VOL_DOWN:
+		{
+			if (mute)
+			{
+				current_volume = old_volume;
+				old_volume = 0;
+				mute = false;
+			}
+
+			if ((current_volume -= aud_get_int("volume_delta")) < 0)
+			{
+				current_volume = 0;
+			}
+
+			if (current_volume != old_volume)
+			{
+				aud_drct_set_volume_main(current_volume);
+			}
+
+			old_volume = current_volume;
+			return true;
+		}
+		break;
+
+	/* increase volume */
+	case EVENT_VOL_UP:
+		{
+			if (mute)
+			{
+				current_volume = old_volume;
+				old_volume = 0;
+				mute = false;
+			}
+
+			if ((current_volume += aud_get_int("volume_delta")) > 100)
+			{
+				current_volume = 100;
+			}
+
+			if (current_volume != old_volume)
+			{
+				aud_drct_set_volume_main(current_volume);
+			}
+
+			old_volume = current_volume;
+			return true;
+		}
+		break;
+
+	/* play */
+	case EVENT_PLAY:
+		{
+			aud_drct_play();
+			return true;
+		}
+		break;
+
+	/* pause */
+	case EVENT_PAUSE:
+		{
+			aud_drct_play_pause();
+			return true;
+		}
+		break;
+
+	/* stop */
+	case EVENT_STOP:
+		{
+			aud_drct_stop();
+			return true;
+		}
+		break;
+
+	/* prev track */
+	case EVENT_PREV_TRACK:
+		{
+			aud_drct_pl_prev();
+			return true;
+		}
+		break;
+
+	/* next track */
+	case EVENT_NEXT_TRACK:
+		{
+			aud_drct_pl_next();
+			return true;
+		}
+		break;
+
+	/* forward */
+	case EVENT_FORWARD:
+		{
+			aud_drct_seek(aud_drct_get_time() + aud_get_int("step_size") * 1000);
+			return true;
+		}
+		break;
+
+	/* backward */
+	case EVENT_BACKWARD:
+		{
+			aud_drct_seek(aud_drct_get_time() - aud_get_int("step_size") * 1000);
+			return true;
+		}
+		break;
+
+	/* Open Jump-To-File dialog */
+	case EVENT_JUMP_TO_FILE:
+		if (!aud_get_headless_mode())
+		{
+			aud_ui_show_jump_to_song();
+			return true;
+		}
+		break;
+
+	/* Toggle Windows */
+	case EVENT_TOGGLE_WIN:
+		if (!aud_get_headless_mode())
+		{
+			aud_ui_show(!aud_ui_is_shown());
+			return true;
+		}
+		break;
+
+	/* Show OSD through AOSD plugin*/
+	case  EVENT_SHOW_AOSD:
+		{
+			hook_call("aosd toggle", nullptr);
+			return true;
+		}
+		break;
+
+	case EVENT_TOGGLE_REPEAT:
+		{
+			aud_toggle_bool("repeat");
+			return true;
+		}
+		break;
+
+	case EVENT_TOGGLE_SHUFFLE:
+		{
+			aud_toggle_bool("shuffle");
+			return true;
+		}
+		break;
+
+	case EVENT_TOGGLE_STOP:
+		{
+			aud_toggle_bool("stop_after_current_song");
+			return true;
+		}
+		break;
+
+	case EVENT_RAISE:
+		{
+			aud_ui_show(true);
+			return true;
+		}
+		break;
+	}
+
+	return false;
+}
+
+void add_hotkey(QList<HotkeyConfiguration> &hotkeys_list, KeySym keysym, int mask, EVENT event)
+{
+	KeyCode keycode;
+	HotkeyConfiguration hotkey;
+
+	if (keysym == 0)
+	{
+		return;
+	}
+
+	keycode = XKeysymToKeycode(QX11Info::display(), keysym);
+	if (keycode == 0)
+	{
+		return;
+	}
+
+	hotkey.key = static_cast<int>(keycode);
+	hotkey.mask = mask;
+	hotkey.event = event;
+
+	hotkeys_list.push_back(hotkey);
+}
+
+void load_defaults()
+{
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioPrev, 0, EVENT_PREV_TRACK);
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioPlay, 0, EVENT_PLAY);
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioPause, 0, EVENT_PAUSE);
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioStop, 0, EVENT_STOP);
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioNext, 0, EVENT_NEXT_TRACK);
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioMute, 0, EVENT_MUTE);
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioRaiseVolume, 0, EVENT_VOL_UP);
+	add_hotkey(plugin_cfg.hotkeys_list, XF86XK_AudioLowerVolume, 0, EVENT_VOL_DOWN);
+}
+
+/* load plugin configuration */
+void load_config()
+{
+	int max = aud_get_int("globalHotkey", "NumHotkeys");
+	if (max == 0)
+	{
+		load_defaults();
+	}
+	else
+	{
+		for (int i = 0; i < max; ++i)
+		{
+			HotkeyConfiguration hotkey;
+
+			hotkey.key = aud_get_int("globalHotkey", QString::fromLatin1("Hotkey_%1_key").arg(i).toLocal8Bit().data());
+			hotkey.mask = aud_get_int("globalHotkey", QString::fromLatin1("Hotkey_%1_mask").arg(i).toLocal8Bit().data());
+			hotkey.event = static_cast<EVENT>(aud_get_int("globalHotkey", QString::fromLatin1("Hotkey_%1_event").arg(i).toLocal8Bit().data()));
+
+			plugin_cfg.hotkeys_list.push_back(hotkey);
+		}
+	}
+}
+
+/* save plugin configuration */
+void save_config()
+{
+	int max = 0;
+
+	for (const auto &hotkey: plugin_cfg.hotkeys_list)
+	{
+		if (hotkey.key != 0)
+		{
+			aud_set_int("globalHotkey", QString::fromLatin1("Hotkey_%1_key").arg(max).toLocal8Bit().data(), hotkey.key);
+			aud_set_int("globalHotkey", QString::fromLatin1("Hotkey_%1_mask").arg(max).toLocal8Bit().data(), hotkey.mask);
+			aud_set_int("globalHotkey", QString::fromLatin1("Hotkey_%1_event").arg(max).toLocal8Bit().data(), hotkey.event);
+			++max;
+		}
+	}
+
+	aud_set_int("globalHotkey", "NumHotkeys", max);
+}
+
+void GlobalHotkeys::cleanup()
+{
+	QCoreApplication::instance()->removeNativeEventFilter(this);
+	ungrab_keys();
+	plugin_cfg.hotkeys_list.clear();
+}
+
+bool GlobalHotkeys::nativeEventFilter(const QByteArray &eventType, void *message, long *result)
+{
+	Q_UNUSED(eventType);
+	Q_UNUSED(result);
+
+	if (!grabbed)
+	{
+		return false;
+	}
+
+	xcb_generic_event_t *e = static_cast<xcb_generic_event_t*>(message);
+
+	if (e->response_type != XCB_KEY_PRESS)
+	{
+		return false;
+	}
+
+	xcb_key_press_event_t *ke = (xcb_key_press_event_t*)e;
+
+	for (const auto &hotkey: plugin_cfg.hotkeys_list)
+	{
+		if ((hotkey.key == ke->detail)
+			&& (hotkey.mask == (ke->state & ~(scrolllock_mask | numlock_mask | capslock_mask))))
+		{
+			if (handle_keyevent(hotkey.event))
+			{
+				return true;
+			}
+		}
+	}
+
+	return false;
+}
+
+/* Taken from xbindkeys */
+static void get_offending_modifiers(Display *dpy)
+{
+	XModifierKeymap *modmap;
+	KeyCode nlock, slock;
+
+	static int mask_table[8] = {
+		ShiftMask, LockMask, ControlMask, Mod1Mask,
+		Mod2Mask, Mod3Mask, Mod4Mask, Mod5Mask
+	};
+
+	nlock = XKeysymToKeycode(dpy, XK_Num_Lock);
+	slock = XKeysymToKeycode(dpy, XK_Scroll_Lock);
+
+	/*
+	* Find out the masks for the NumLock and ScrollLock modifiers,
+	* so that we can bind the grabs for when they are enabled too.
+	*/
+	modmap = XGetModifierMapping(dpy);
+
+	if ((modmap != nullptr) && (modmap->max_keypermod > 0))
+	{
+		for (int i = 0; i < 8 * modmap->max_keypermod; ++i)
+		{
+			if ((modmap->modifiermap[i] == nlock) && (nlock != 0))
+			{
+				numlock_mask = mask_table[i / modmap->max_keypermod];
+			}
+			else if ((modmap->modifiermap[i] == slock) && (slock != 0))
+			{
+				scrolllock_mask = mask_table[i / modmap->max_keypermod];
+			}
+		}
+	}
+
+	capslock_mask = LockMask;
+
+	if (modmap)
+	{
+		XFreeModifiermap (modmap);
+	}
+}
+
+
+static int x11_error_handler(Display *dpy, XErrorEvent *error)
+{
+	return 0;
+}
+
+/* grab required keys */
+static void grab_key(const HotkeyConfiguration &hotkey, Display *xdisplay, Window x_root_window)
+{
+	unsigned int modifier = hotkey.mask & ~(numlock_mask | capslock_mask | scrolllock_mask);
+
+	if (hotkey.key == 0)
+	{
+		return;
+	}
+
+	XGrabKey(xdisplay, hotkey.key, modifier, x_root_window,
+		False, GrabModeAsync, GrabModeAsync);
+
+	if (modifier == AnyModifier)
+	{
+		return;
+	}
+
+	if (numlock_mask)
+	{
+		XGrabKey(xdisplay, hotkey.key, modifier | numlock_mask,
+			x_root_window,
+			False, GrabModeAsync, GrabModeAsync);
+	}
+
+	if (capslock_mask)
+	{
+		XGrabKey(xdisplay, hotkey.key, modifier | capslock_mask,
+			x_root_window,
+			False, GrabModeAsync, GrabModeAsync);
+	}
+
+	if (scrolllock_mask)
+	{
+		XGrabKey(xdisplay, hotkey.key, modifier | scrolllock_mask,
+			x_root_window,
+			False, GrabModeAsync, GrabModeAsync);
+		}
+
+	if (numlock_mask && capslock_mask)
+	{
+		XGrabKey(xdisplay, hotkey.key, modifier | numlock_mask | capslock_mask,
+			x_root_window,
+			False, GrabModeAsync, GrabModeAsync);
+	}
+
+	if (numlock_mask && scrolllock_mask)
+	{
+		XGrabKey(xdisplay, hotkey.key, modifier | numlock_mask | scrolllock_mask,
+			x_root_window,
+			False, GrabModeAsync, GrabModeAsync);
+		}
+
+	if (capslock_mask && scrolllock_mask)
+	{
+		XGrabKey(xdisplay, hotkey.key, modifier | capslock_mask | scrolllock_mask,
+			x_root_window,
+			False, GrabModeAsync, GrabModeAsync);
+	}
+
+	if (numlock_mask && capslock_mask && scrolllock_mask)
+	{
+		XGrabKey(xdisplay, hotkey.key,
+			modifier | numlock_mask | capslock_mask | scrolllock_mask,
+			x_root_window, False, GrabModeAsync,
+			GrabModeAsync);
+	}
+}
+
+void grab_keys()
+{
+	PluginConfig *plugin_cfg = get_config();
+
+	XErrorHandler old_handler = nullptr;
+	Display *xdisplay = QX11Info::display();
+
+	if (grabbed || (!xdisplay))
+	{
+		return;
+	}
+
+	XSync(xdisplay, False);
+	old_handler = XSetErrorHandler(x11_error_handler);
+
+	get_offending_modifiers(xdisplay);
+
+	for (const auto &hotkey: plugin_cfg->hotkeys_list)
+	{
+		for (int screen = 0; screen < ScreenCount(xdisplay); ++screen)
+		{
+			grab_key(hotkey, xdisplay, RootWindow(xdisplay, screen));
+		}
+	}
+
+	XSync(xdisplay, False);
+	XSetErrorHandler(old_handler);
+
+	grabbed = 1;
+}
+
+/* grab required keys */
+static void ungrab_key(const HotkeyConfiguration &hotkey, Display *xdisplay, Window x_root_window)
+{
+	unsigned int modifier = hotkey.mask & ~(numlock_mask | capslock_mask | scrolllock_mask);
+
+	if (hotkey.key == 0)
+	{
+		return;
+	}
+
+	XUngrabKey(xdisplay, hotkey.key, modifier, x_root_window);
+
+	if (modifier == AnyModifier)
+	{
+		return;
+	}
+
+	if (numlock_mask)
+	{
+		XUngrabKey(xdisplay, hotkey.key, modifier | numlock_mask, x_root_window);
+	}
+
+	if (capslock_mask)
+	{
+		XUngrabKey(xdisplay, hotkey.key, modifier | capslock_mask, x_root_window);
+	}
+
+	if (scrolllock_mask)
+	{
+		XUngrabKey(xdisplay, hotkey.key, modifier | scrolllock_mask, x_root_window);
+	}
+
+	if (numlock_mask && capslock_mask)
+	{
+		XUngrabKey(xdisplay, hotkey.key, modifier | numlock_mask | capslock_mask, x_root_window);
+	}
+
+	if (numlock_mask && scrolllock_mask)
+	{
+		XUngrabKey(xdisplay, hotkey.key, modifier | numlock_mask | scrolllock_mask, x_root_window);
+	}
+
+	if (capslock_mask && scrolllock_mask)
+	{
+		XUngrabKey(xdisplay, hotkey.key, modifier | capslock_mask | scrolllock_mask, x_root_window);
+	}
+
+	if (numlock_mask && capslock_mask && scrolllock_mask)
+	{
+		XUngrabKey(xdisplay, hotkey.key, modifier | numlock_mask | capslock_mask | scrolllock_mask, x_root_window);
+	}
+}
+
+void ungrab_keys()
+{
+	PluginConfig *plugin_cfg = get_config();
+
+	XErrorHandler old_handler = nullptr;
+	Display *xdisplay = QX11Info::display();
+
+	if ((!grabbed) || (!xdisplay))
+	{
+		return;
+	}
+
+	XSync(xdisplay, False);
+	old_handler = XSetErrorHandler(x11_error_handler);
+
+	get_offending_modifiers(xdisplay);
+
+	for (const auto &hotkey: plugin_cfg->hotkeys_list)
+	{
+		for (int screen = 0; screen < ScreenCount(xdisplay); ++screen)
+		{
+			ungrab_key(hotkey, xdisplay, RootWindow(xdisplay, screen));
+		}
+	}
+
+	XSync(xdisplay, False);
+	XSetErrorHandler(old_handler);
+
+	grabbed = 0;
+}
diff --git a/src/qthotkey/plugin.h b/src/qthotkey/plugin.h
new file mode 100644
index 000000000..e72925d94
--- /dev/null
+++ b/src/qthotkey/plugin.h
@@ -0,0 +1,50 @@
+#ifndef _PLUGIN_H_INCLUDED_
+#define _PLUGIN_H_INCLUDED_
+
+#include <QtCore/QList>
+
+typedef enum {
+	EVENT_PREV_TRACK = 0,
+	EVENT_PLAY,
+	EVENT_PAUSE,
+	EVENT_STOP,
+	EVENT_NEXT_TRACK,
+
+	EVENT_FORWARD,
+	EVENT_BACKWARD,
+	EVENT_MUTE,
+	EVENT_VOL_UP,
+	EVENT_VOL_DOWN,
+	EVENT_JUMP_TO_FILE,
+	EVENT_TOGGLE_WIN,
+	EVENT_SHOW_AOSD,
+
+	EVENT_TOGGLE_REPEAT,
+	EVENT_TOGGLE_SHUFFLE,
+	EVENT_TOGGLE_STOP,
+
+	EVENT_RAISE,
+
+	EVENT_MAX
+} EVENT;
+
+
+struct HotkeyConfiguration {
+	unsigned key, mask;
+	EVENT event;
+};
+
+typedef struct {
+	/* keyboard */
+	QList<HotkeyConfiguration> hotkeys_list;
+} PluginConfig;
+
+void load_config();
+void save_config();
+PluginConfig* get_config();
+bool handle_keyevent(EVENT event);
+
+void grab_keys();
+void ungrab_keys();
+
+#endif
-- 
2.24.1

